

RK := proc(f, g, a, b, y0, z0, r)
  local h, yz, i, k1, k2, k3, k4, l1, l2, l3, l4, k, l;
begin
  h := (b-a)/r:
 
  yz := [[a, y0, z0]]:
  
  for i from float(a+h) to float(b) step float(h) do:
    k1 := float(h*f(yz[-1][1], yz[-1][2], yz[-1][3]));
    l1 := float(h*g(yz[-1][1], yz[-1][2], yz[-1][3]));

    k2 := float(h*f(yz[-1][1]+h/2, yz[-1][2]+k1/2, yz[-1][3]+l1/2));
    l2 := float(h*g(yz[-1][1]+h/2, yz[-1][2]+k1/2, yz[-1][3]+l1/2));
    
    k3 := float(h*f(yz[-1][1]+h/2, yz[-1][2]+k2/2, yz[-1][3]+l2/2));
    l3 := float(h*g(yz[-1][1]+h/2, yz[-1][2]+k2/2, yz[-1][3]+l2/2));
    
    k4 := float(h*f(yz[-1][1]+h, yz[-1][2]+k3, yz[-1][3]+l3));
    l4 := float(h*g(yz[-1][1]+h, yz[-1][2]+k3, yz[-1][3]+l3));
    
    k := float((1/6)*(k1+2*k2+2*k3+k4));

    l := float((1/6)*(l1+2*l2+2*l3+l4));
    
    yz := [op(yz), [yz[-1][1]+h, yz[-1][2]+k, yz[-1][3]+l]];
   
  end:
  
   return(yz):

end:


Tir := proc(f, g, x0, x1, y0, y1, p)
  local a, b, ha, hb, w, f0, f1, fab, fonction, derivee, points;
begin
  a := 0:
  b := 0:
  f0 := RK(f, g, x0, x1, y0, 0, 1)[-1][2]: 
  f1 := RK(f, g, x0, x1, y0, 1, 1)[-1][2]:

  if f0 < f1 and f0 < y1 then ha := 1: hb := 0: 
  elif f0 < f1 and f0 > y1 then ha := 0: hb := -1:
  elif f0 > f1 and f0 < y1 then ha := -1: hb := 0:
  elif f0 > f1 and f0 > y1 then ha := 0: hb := 1:
  elif f0 = Dom::Float(y1) then ha := 0: hb := 0 end:
  
  while RK(f, g, x0, x1, y0, a, 1)[-1][2] < y1 do: 
    a := a + ha:
  end:

  while RK(f, g, x0, x1, y0, b, 1)[-1][2] > y1 do: 
    b := b + hb:
  end:

  repeat 
    fab := RK(f, g, x0, x1, y0, (a+b)/2, 100)[-1][2]:
    if fab > y1 then a := float(((a+b)/2)):
    elif fab < y1 then b := float(((a+b)/2)): end:
   
    w := abs(RK(f, g, x0, x1, y0, (a+b)/2, 100)[-1][2] - y1)/abs(y1):print(w)
  until w <= p end: 
    
  fonction := []:
  derivee := []:
  points := RK(f, g, x0, x1, y0, (a+b)/2, 100):  
  
  for i from 1 to nops(points) do 
    fonction := [op(fonction), [points[i][1], points[i][2]]]:
    derivee := [op(derivee), [points[i][1], points[i][3]]]:
  end:

  return((a+b)/2, fonction, derivee):

end:
Applications de la méthode de Tirs :

     - équation différentielle linéaire d'ordre 1 : 
       
              Radioactivité : désintégration d'une population de noyaux radioactifs : cas du Carbone 14 :


`&lambda;`:=1.210*10^-4//constante radioactive (unité : an^-1)


x0:=0//temps initial


x1:=5730//demi-vie radioactive (unité : an)


y0:=10000//population initiale d'atomes


y1:=5000//population d'atomes à à la demi-vie radioactive


p:=0.01//précision du résultat


f:=(-1/`&lambda;`)*z(x);
g:=0




